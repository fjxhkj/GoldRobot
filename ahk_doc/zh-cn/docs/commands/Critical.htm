<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<title>Critical</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<link href="../static/theme.css" rel="stylesheet" type="text/css" />
<script src="../static/content.js" type="text/javascript"></script>
</head>
<body>

<h1>Critical</h1>

<p>防止<a href="../misc/Threads.htm">当前线程</a>被其他线程中断, 或开启可中断.</p>

<pre class="Syntax">Critical [, Off]
Critical 50 <em>; 请参阅<a href="#Interval">备注底部</a>。</em></pre>
<p>如果首个参数省略 (或为单词 On), 则设置 <a href="../misc/Threads.htm">当前线程</a> 为关键的, 这意味着它不会被其他线程中断. 如果首个参数为 Off（或在 v1.0.48+ 为数字 0），则当前线程会不论 <a href="Thread.htm">Thread Interrupt</a> 设置如何都会变成可中断状态。</p>

<h3 id="Behave">Behavior of Critical Threads</h3>
<p>与 <a href="../misc/Threads.htm">高优先级</a> 线程不同, 在关键线程中产生的事件不会被丢弃. 例如, 在当前线程为关键线程时用户按下了 <a href="../Hotkeys.htm">热键</a>, 那么此热键会被缓冲到当前线程结束或成为非关键线程时才作为新的线程启动.</p>
<p>关键线程也会被紧急事件中断. 紧急事件包括: 1) <a href="OnExit.htm">OnExit</a> 子程序; 2) 监听消息号小于 0x312 的任何 <a href="OnMessage.htm">OnMessage()</a> 函数 (或被这些消息触发的 <a href="RegisterCallback.htm">回调</a>); 和 3) 由紧急线程自身间接触发的任何 <a href="RegisterCallback.htm">回调</a> (例如通过 <a href="PostMessage.htm">SendMessage</a> 或 <a href="DllCall.htm">DllCall</a>). 要避免被这些事件中断, 可以临时禁用这些函数.</p>
<p>关键线程在显示 <a href="MsgBox.htm">MsgBox</a> 或其他对话框时, 会变成可中断的. 但是，与 <a href="Thread.htm">Thread Interrupt</a> 不同，在用户解除对话框后这个线程会再恢复为关键的。</p>

<h3 id="Off">Critical Off</h3>
<p>当缓冲的事件等待启动新的线程时, 使用 <code>Critical Off</code> 不会导致立即中断当前线程. Instead, an average of 5 milliseconds will pass before an interruption occurs. This makes it more than 99.999% likely that at least one line after <code>Critical Off</code> will execute before an interruption. You can force interruptions to occur immediately by means of a delay such as a <code><a href="Sleep.htm">Sleep -1</a></code> or a <a href="WinWait.htm">WinWait</a> for a window that does not yet exist.</p>
<p><code>Critical Off</code> cancels the current thread's period of uninterruptibility even if the thread was not Critical, thereby letting events such as <a href="Gui.htm#GuiSize">GuiSize</a> be processed sooner or more predictably.</p>

<h3 id="Settings">Thread Settings</h3>
<p>See <a href="../Variables.htm#IsCritical">A_IsCritical</a> for how to save and restore the current setting of Critical. However, since Critical is a thread-specific setting, when a critical thread ends, the underlying/resumed thread (if any) will  be automatically noncritical. Consequently there is no need to do &quot;Critical Off&quot; right before ending a thread.</p>
<p>If Critical is not used in the auto-execute section (top part of the script), all threads start off as noncritical (though the settings of <a href="Thread.htm">Thread Interrupt</a> will still apply). By contrast, if the auto-execute section turns on Critical but never turns it off, every newly launched <a href="../misc/Threads.htm">thread</a> (such as a <a href="../Hotkeys.htm">hotkey</a>, <a href="Menu.htm">custom menu item</a>, or <a href="SetTimer.htm">timed</a> subroutine) starts off critical.</p>
<p>The command <a href="Thread.htm">Thread NoTimers</a> is similar to Critical except that it only prevents interruptions from <a href="SetTimer.htm">timers</a>.</p>
<p>在 v1.0.47+，打开 Critical 的同时也会让 <a href="SetBatchLines.htm"><code>SetBatchLines -1</code></a> 对<a href="../misc/Threads.htm">当前线程</a>生效。</p>

<h3 id="Interval">Message Check Interval</h3>
<p>In v1.0.47+, specifying a positive number as the first parameter (e.g. <code>Critical 30</code>) turns on Critical but also changes the number of milliseconds between checks of the internal message queue. If unspecified, messages are checked every 16 milliseconds while Critical is On, and every 5 ms while Critical is Off. Increasing the interval postpones the arrival of messages/events, which gives the <a href="../misc/Threads.htm">current thread</a> more time to finish. This reduces the possibility that certain <a href="OnMessage.htm">OnMessage()</a> and <a href="Gui.htm#DefaultWin">GUI events</a> will be lost due to &quot;thread already running&quot;. However, commands that wait such as <a href="Sleep.htm">Sleep</a> and <a href="WinWait.htm">WinWait</a> will check messages regardless of this setting (a workaround is <code>DllCall(&quot;Sleep&quot;, Uint, 500)</code>). Note: Increasing the message-check interval too much may reduce the responsiveness of various events such as <a href="Gui.htm">GUI</a> window repainting.</p>

<h3>相关</h3>
<p><a href="Thread.htm">Thread（命令）</a>, <a href="../misc/Threads.htm">线程</a>, <a href="_MaxThreadsPerHotkey.htm">#MaxThreadsPerHotkey</a>, <a href="_MaxThreadsBuffer.htm">#MaxThreadsBuffer</a>, <a href="OnMessage.htm">OnMessage()</a>, <a href="RegisterCallback.htm">RegisterCallback()</a>, <a href="Hotkey.htm">Hotkey</a>, <a href="Menu.htm">Menu</a>, <a href="SetTimer.htm">SetTimer</a></p>

<h3>示例</h3>
<pre class="NoIndent">#space::  <em>; Win+Space 热键.</em>
Critical
ToolTip No new threads will launch until after this ToolTip disappears.
Sleep 3000
ToolTip  <em>; 关闭提示.</em>
return  <em>; 从热键子程序中返回, 这样结束了当前线程. 后面的线程会按设置恢复为非关键的.</em></pre>

</body>
</html>
